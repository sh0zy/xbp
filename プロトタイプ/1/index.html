<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8" />
<title>Wave App Builder â€“ Hybrid Analyze Prototype</title>
<style>
  body {
    margin: 0;
    background: #05081b;
    color: #fff;
    font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
  }

  .top-bar {
    display: flex;
    justify-content: space-between;
    padding: 12px 20px;
    background: #070b23;
    border-bottom: 1px solid rgba(255,255,255,0.06);
  }
  .logo { font-weight: 600; }
  .mode-switch { margin-right: 12px; font-size: 14px; }
  .top-bar .right button { margin-left: 6px; }

  .guide-area {
    background: rgba(77, 124, 255, 0.18);
    padding: 12px 16px;
    border-radius: 12px;
    margin: 10px 20px;
    font-size: 15px;
    color: #dce3ff;
    backdrop-filter: blur(6px);
  }

  .main-layout {
    display: flex;
    gap: 20px;
    padding: 20px;
  }

  .input-area {
    flex: 1;
    background: rgba(255,255,255,0.04);
    padding: 20px;
    border-radius: 16px;
  }

  textarea {
    width: 100%;
    height: 220px;
    padding: 12px;
    border-radius: 12px;
    background: rgba(255,255,255,0.12);
    border: none;
    color: #fff;
    resize: none;
    font-size: 14px;
  }

  .input-actions {
    display: flex;
    justify-content: space-between;
    margin-top: 8px;
    font-size: 13px;
    color: #9aa4ff;
  }

  .preview-area {
    flex: 1;
    background: rgba(255,255,255,0.04);
    padding: 20px;
    border-radius: 16px;
  }

  .preview-frame {
    width: 360px;
    height: 640px;
    background: #11152f;
    border-radius: 20px;
    padding: 20px;
    overflow-y: auto;
    margin-bottom: 10px;
    box-shadow: 0 0 20px rgba(0,0,0,0.35);
  }

  .preview-placeholder {
    opacity: 0.6;
    font-size: 14px;
  }

  .next-actions {
    padding: 0 20px 20px;
  }
  .next-actions ul {
    margin: 6px 0 0;
    padding-left: 18px;
    font-size: 14px;
  }

  .pro-panels {
    display: none;
    grid-template-columns: 260px 1fr 300px;
    gap: 16px;
    padding: 0 20px 20px;
  }
  .panel {
    background: rgba(255,255,255,0.05);
    border-radius: 14px;
    padding: 16px;
    backdrop-filter: blur(6px);
    height: 520px;
    overflow-y: auto;
    font-size: 14px;
  }
  .panel h3 {
    margin-top: 0;
    margin-bottom: 8px;
    font-size: 14px;
    opacity: 0.9;
  }
  #canvasArea {
    background: #11152f;
    border-radius: 16px;
    height: 460px;
    padding: 20px;
  }

  #propertyContent label {
    display: block;
    margin-top: 10px;
    font-size: 13px;
  }
  #propertyContent input {
    width: 100%;
    padding: 6px;
    border-radius: 8px;
    border: none;
    margin-top: 4px;
    font-size: 13px;
  }

  .flow-panel {
    display: none;
    background: rgba(255,255,255,0.04);
    margin: 0 20px 20px;
    padding: 20px;
    border-radius: 16px;
  }
  .flow-panel h3 {
    margin-top: 0;
    font-size: 14px;
  }
  .flow-canvas {
    position: relative;
    width: 100%;
    height: 260px;
    background: rgba(0,0,0,0.3);
    border-radius: 12px;
    overflow: hidden;
  }
  #flowSvg {
    position: absolute;
    inset: 0;
    pointer-events: none;
  }
  #flowNodes {
    position: absolute;
    inset: 0;
  }
  .flow-node {
    position: absolute;
    padding: 6px 10px;
    border-radius: 10px;
    background: rgba(255,255,255,0.15);
    color: #fff;
    font-size: 13px;
    white-space: nowrap;
  }
  .transition-line {
    stroke-dasharray: 6 4;
    animation: waveFlow 4s linear infinite;
    opacity: 0.85;
  }
  @keyframes waveFlow {
    from { stroke-dashoffset: 0; }
    to   { stroke-dashoffset: -30; }
  }

  .help {
    position: fixed;
    inset: 0;
    background: rgba(0,0,0,0.7);
    padding: 40px;
    display: none;
  }
  .help-inner {
    max-width: 480px;
    margin: 40px auto;
    background: #11152f;
    border-radius: 16px;
    padding: 20px;
  }

  button {
    background: #4d7cff;
    color: #fff;
    border: none;
    border-radius: 999px;
    padding: 8px 16px;
    font-size: 13px;
    cursor: pointer;
  }
  button:disabled {
    opacity: 0.5;
    cursor: default;
  }
</style>
</head>
<body>

<header class="top-bar">
  <div class="left">
    <span class="logo">Wave App Builder</span>
  </div>
  <div class="right">
    <label class="mode-switch">
      <input type="checkbox" id="minimalModeToggle" checked>
      ãƒŸãƒ‹ãƒãƒ ãƒ¢ãƒ¼ãƒ‰
    </label>
    <button id="guideModeToggle">ã‚¬ã‚¤ãƒ‰ãƒ¢ãƒ¼ãƒ‰ ON</button>
    <button id="helpBtn">ãƒ˜ãƒ«ãƒ—</button>
  </div>
</header>

<div id="guideArea" class="guide-area">
  ğŸ’¡ æ¬¡ã¯ã€Œã‚¢ãƒ—ãƒªã®èª¬æ˜ã€ã‚’æ›¸ã„ã¦ã¿ã‚ˆã†ã€‚ã‚ãªãŸã®è¨€è‘‰ã§å¤§ä¸ˆå¤«ã ã‚ˆã€‚
</div>

<div class="main-layout">
  <section id="inputArea" class="input-area">
    <h3>ğŸ“ ã‚ãªãŸã®ã‚¢ãƒ—ãƒªã«ã¤ã„ã¦æ•™ãˆã¦ãã ã•ã„</h3>
    <textarea id="appInput"
placeholder="ä¾‹ï¼š
ãƒ¡ãƒ¢ã®ä¸€è¦§ç”»é¢ã¨è©³ç´°ç”»é¢ã‚’ä½œã‚ŠãŸã„ã€‚
ä¸€è¦§ç”»é¢ã«ã¯ãƒ¡ãƒ¢ã®ã‚¿ã‚¤ãƒˆãƒ«ã‚’ä¸¦ã¹ã¦ã€ã‚¿ãƒƒãƒ—ã™ã‚‹ã¨è©³ç´°ç”»é¢ã¸é·ç§»ã—ãŸã„ã€‚
è©³ç´°ç”»é¢ã§ã¯ã‚¿ã‚¤ãƒˆãƒ«ã¨å†…å®¹ã‚’è¡¨ç¤ºã—ã¦ã€æˆ»ã‚‹ãƒœã‚¿ãƒ³ã§ä¸€è¦§ã«æˆ»ã‚ŠãŸã„ã€‚"></textarea>
    <div class="input-actions">
      <span id="autoSaveStatus">å…¥åŠ›å¾…ã¡</span>
      <div>
        <button id="undoBtn" disabled>Undo</button>
        <button id="redoBtn" disabled>Redo</button>
      </div>
    </div>
  </section>

  <section id="previewArea" class="preview-area">
    <h3>ğŸ“± ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼</h3>
    <div id="previewFrame" class="preview-frame">
      <div class="preview-placeholder">
        ã“ã“ã«ã‚ãªãŸã®ã‚¢ãƒ—ãƒªãŒè¡¨ç¤ºã•ã‚Œã¾ã™ã€‚
      </div>
    </div>
    <button id="installPWABtn" disabled>ãƒ›ãƒ¼ãƒ ç”»é¢ã«è¿½åŠ ï¼ˆPWAãƒ»ãƒ€ãƒŸãƒ¼ï¼‰</button>
  </section>
</div>

<section id="nextActionsArea" class="next-actions">
  <h3>âœ¨ æ¬¡ã«ã§ãã‚‹ã“ã¨</h3>
  <ul id="nextActions"></ul>
</section>

<section id="proModePanels" class="pro-panels">
  <div id="treeView" class="panel">
    <h3>ğŸ“‚ éšå±¤æ§‹é€ </h3>
    <div id="treeContent"></div>
  </div>
  <div id="canvasPanel" class="panel">
    <h3>ğŸ–¥ï¸ ã‚­ãƒ£ãƒ³ãƒã‚¹</h3>
    <div id="canvasArea"></div>
  </div>
  <div id="propertyPanel" class="panel">
    <h3>âš™ï¸ ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£</h3>
    <div id="propertyContent"></div>
  </div>
</section>

<section id="screenFlowArea" class="flow-panel">
  <h3>ğŸ”— ç”»é¢é·ç§»ãƒ•ãƒ­ãƒ¼</h3>
  <div id="screenFlowCanvas" class="flow-canvas">
    <svg id="flowSvg"></svg>
    <div id="flowNodes"></div>
  </div>
</section>

<div id="helpPage" class="help">
  <div class="help-inner">
    <h2>5åˆ†ã§åˆ†ã‹ã‚‹ Wave App Builder</h2>
    <p>æ–‡ç« ã‚’æ›¸ã â†’ ã‚¢ãƒ—ãƒªãŒã§ãã‚‹ â†’ è§¦ã£ã¦è‚²ã¦ã‚‹ã€‚</p>
    <p>ã¯ã˜ã‚ã¯ãƒŸãƒ‹ãƒãƒ ãƒ¢ãƒ¼ãƒ‰ã§ã€æ…£ã‚ŒãŸã‚‰ãƒŸãƒ‹ãƒãƒ ã‚’OFFã«ã—ã¦ãƒ—ãƒ­ãƒ¢ãƒ¼ãƒ‰ã‚’è©¦ã—ã¦ã¿ã¦ãã ã•ã„ã€‚</p>
    <button id="closeHelp">é–‰ã˜ã‚‹</button>
  </div>
</div>

<script>
let appState = {
  structure: null,
  history: [],
  future: [],
  minimalMode: true,
  guideMode: true
};

/* ====== è¾æ›¸ãƒ»ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ ====== */

const SCREEN_KEYWORDS = [
  "ç”»é¢","ãƒšãƒ¼ã‚¸","ä¸€è¦§","è©³ç´°","è¨­å®š","ãƒ—ãƒ­ãƒ•ã‚£ãƒ¼ãƒ«",
  "ãƒ›ãƒ¼ãƒ ","ãƒˆãƒƒãƒ—","ãƒ¡ãƒ‹ãƒ¥ãƒ¼","ãƒ­ã‚°ã‚¤ãƒ³","ç™»éŒ²"
];

const COMPONENT_PATTERNS = [
  { type: "button", keywords: ["ãƒœã‚¿ãƒ³","æŠ¼ã™","ã‚¯ãƒªãƒƒã‚¯","é€ä¿¡","è¿½åŠ ","æˆ»ã‚‹"] },
  { type: "input", keywords: ["å…¥åŠ›","ãƒ•ã‚©ãƒ¼ãƒ ","è¨˜å…¥","æ›¸ã"] },
  { type: "list", keywords: ["ä¸€è¦§","ãƒªã‚¹ãƒˆ","è¤‡æ•°","ä¸¦ã¹ã‚‹"] },
  { type: "card", keywords: ["ã‚«ãƒ¼ãƒ‰","æ "] },
  { type: "image", keywords: ["ç”»åƒ","å†™çœŸ"] },
  { type: "toggle", keywords: ["ã‚ªãƒ³","ã‚ªãƒ•","åˆ‡ã‚Šæ›¿ãˆ"] },
  { type: "checkbox", keywords: ["ãƒã‚§ãƒƒã‚¯","å®Œäº†"] }
];

const TRANSITION_PATTERNS = [
  { pattern: /(.+)ã‚’æŠ¼ã™ã¨(.+)ã¸/, label: "navigate" },
  { pattern: /(.+)ã‚’é–‹ã/, label: "open" },
  { pattern: /æˆ»ã‚‹/, label: "back" },
  { pattern: /è©³ç´°ã‚’è¦‹ã‚‹/, label: "detail" }
];

function normalizeId(name) {
  return (name || "screen")
    .replace(/[^\wä¸€-é¾ ã-ã‚“ã‚¡-ãƒ³]/g, "_")
    .replace(/_+/g, "_")
    .toLowerCase();
}

/* ====== ãƒã‚¤ãƒ–ãƒªãƒƒãƒ‰ analyze ãƒ¡ã‚¤ãƒ³ ====== */

async function analyzeHybrid(userText) {
  const base = analyzeRuleBased(userText);
  const refined = await refineStructureWithLLM(userText, base);
  const safe = sanitizeStructure(refined || base);
  return safe;
}

/* ====== ãƒ«ãƒ¼ãƒ«ãƒ™ãƒ¼ã‚¹ analyze ====== */

function analyzeRuleBased(text) {
  const lines = text.split("\n").map(l => l.trim()).filter(Boolean);
  const screens = [];
  const transitions = [];
  const models = {};

  let currentScreen = null;

  for (const line of lines) {
    if (SCREEN_KEYWORDS.some(k => line.includes(k))) {
      const id = normalizeId(line);
      currentScreen = { id, name: line, components: [] };
      screens.push(currentScreen);
      continue;
    }

    const comp = detectComponent(line);
    if (comp && currentScreen) {
      currentScreen.components.push(comp);
    }

    const tr = detectTransition(line, screens);
    if (tr) transitions.push(tr);

    detectModel(line, models);
  }

  autoLinkListToDetail(screens, transitions);

  // ç”»é¢ãŒ1ã¤ã‚‚ãªã„å ´åˆã¯ã€Œãƒ›ãƒ¼ãƒ ã€ã‚’ä»®è¿½åŠ 
  if (screens.length === 0) {
    screens.push({
      id: "home",
      name: "ãƒ›ãƒ¼ãƒ ",
      components: [
        { type: "text", text: "ã¾ã ç”»é¢ãŒå®šç¾©ã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚" }
      ]
    });
  }

  return { screens, transitions, models };
}

function detectComponent(line) {
  for (const pattern of COMPONENT_PATTERNS) {
    if (pattern.keywords.some(k => line.includes(k))) {
      return { type: pattern.type, text: line };
    }
  }
  if (line.includes("ã‚¿ã‚¤ãƒˆãƒ«")) return { type: "text", text: "ã‚¿ã‚¤ãƒˆãƒ«" };
  if (line.includes("å†…å®¹")) return { type: "textarea", text: "å†…å®¹" };
  return null;
}

function detectTransition(line, screens) {
  for (const t of TRANSITION_PATTERNS) {
    const match = line.match(t.pattern);
    if (match) {
      const from = findScreenId(match[1], screens) || (screens[0] && screens[0].id);
      const to = findScreenId(match[2], screens);
      if (from && to) return { from, to, label: t.label };
    }
  }
  if (line.includes("æˆ»ã‚‹") && screens.length >= 2) {
    return { from: screens[1].id, to: screens[0].id, label: "æˆ»ã‚‹" };
  }
  return null;
}

function findScreenId(name, screens) {
  const s = screens.find(s => s.name.includes(name));
  return s ? s.id : null;
}

function detectModel(line, models) {
  const nouns = extractNouns(line);
  nouns.forEach(n => {
    if (!models[n]) models[n] = { name: n, fields: [] };
  });
  if (line.includes("ã‚¿ã‚¤ãƒˆãƒ«")) addField(models, "ãƒ¡ãƒ¢", "title", "string");
  if (line.includes("å†…å®¹")) addField(models, "ãƒ¡ãƒ¢", "body", "string");
}

function extractNouns(line) {
  return line.match(/[ä¸€-é¾ ã-ã‚“ã‚¡-ãƒ³a-zA-Z0-9]+/g) || [];
}

function addField(models, modelName, fieldName, type) {
  if (!models[modelName]) models[modelName] = { name: modelName, fields: [] };
  if (!models[modelName].fields.find(f => f.name === fieldName)) {
    models[modelName].fields.push({ name: fieldName, type });
  }
}

function autoLinkListToDetail(screens, transitions) {
  const listScreens = screens.filter(s => s.name.includes("ä¸€è¦§"));
  const detailScreens = screens.filter(s => s.name.includes("è©³ç´°"));
  listScreens.forEach(ls => {
    detailScreens.forEach(ds => {
      if (!transitions.find(t => t.from === ls.id && t.to === ds.id)) {
        transitions.push({
          from: ls.id,
          to: ds.id,
          label: "è©³ç´°ã¸"
        });
      }
    });
  });
}

/* ====== LLM ãƒ¢ãƒƒã‚¯ï¼ˆä»Šã¯â€œãã‚Œã£ã½ãæ•´ãˆã‚‹ã ã‘â€ï¼‰ ====== */

async function refineStructureWithLLM(userText, baseStructure) {
  // æœ¬ç•ªã§ã¯ã“ã“ã§å®Ÿéš›ã® LLM API ã‚’å©ãã€‚
  // ä»Šã¯ã€Œå°‘ã—ãƒ©ãƒ™ãƒ«ã‚’æ•´ãˆã‚‹ã ã‘ã€ã®ãƒ¢ãƒƒã‚¯å®Ÿè£…ã«ã—ã¦ã‚ã‚‹ã€‚

  const cloned = JSON.parse(JSON.stringify(baseStructure));

  cloned.screens.forEach((s, idx) => {
    if (!s.role) {
      if (s.name.includes("ä¸€è¦§")) s.role = "list";
      else if (s.name.includes("è©³ç´°")) s.role = "detail";
      else if (idx === 0) s.role = "home";
      else s.role = "other";
    }

    s.components.forEach(c => {
      if (c.type === "button" && (!c.text || c.text.length < 2)) {
        c.text = "ãƒœã‚¿ãƒ³";
      }
      if (c.type === "list" && (!c.text || c.text.length < 2)) {
        c.text = s.name + "ã®ä¸€è¦§";
      }
    });
  });

  return cloned;
}

/* ====== ã‚µãƒ‹ã‚¿ã‚¤ã‚º ====== */

function sanitizeStructure(struct) {
  if (!struct || !Array.isArray(struct.screens)) {
    return { screens: [], transitions: [], models: [] };
  }

  const allowedTypes = ["text","input","textarea","button","list","card","image","toggle","checkbox"];
  const screenIds = new Set();

  struct.screens.forEach(s => {
    if (!s.id) s.id = normalizeId(s.name || "screen");
    if (screenIds.has(s.id)) s.id += "_" + Math.random().toString(16).slice(2, 6);
    screenIds.add(s.id);
    if (!Array.isArray(s.components)) s.components = [];
    s.components = s.components.filter(c => c && allowedTypes.includes(c.type));
  });

  struct.transitions = (struct.transitions || []).filter(tr =>
    screenIds.has(tr.from) && screenIds.has(tr.to)
  );

  if (!Array.isArray(struct.models)) struct.models = [];

  return struct;
}

/* ====== UI ãƒ­ã‚¸ãƒƒã‚¯ ====== */

document.getElementById("minimalModeToggle").addEventListener("change", e => {
  appState.minimalMode = e.target.checked;
  setMinimalMode(appState.minimalMode);
});
document.getElementById("guideModeToggle").addEventListener("click", () => {
  appState.guideMode = !appState.guideMode;
  document.getElementById("guideModeToggle").textContent =
    appState.guideMode ? "ã‚¬ã‚¤ãƒ‰ãƒ¢ãƒ¼ãƒ‰ ON" : "ã‚¬ã‚¤ãƒ‰ãƒ¢ãƒ¼ãƒ‰ OFF";
  renderGuideMessage();
});
document.getElementById("helpBtn").addEventListener("click", () => {
  document.getElementById("helpPage").style.display = "block";
});
document.getElementById("closeHelp").addEventListener("click", () => {
  document.getElementById("helpPage").style.display = "none";
});

function setMinimalMode(isMinimal) {
  document.getElementById("proModePanels").style.display = isMinimal ? "none" : "grid";
  document.getElementById("screenFlowArea").style.display = isMinimal ? "none" : "block";
  renderGuideMessage();
}

function renderGuideMessage() {
  const guide = document.getElementById("guideArea");
  if (!appState.guideMode) {
    guide.textContent = appState.minimalMode
      ? "ãƒŸãƒ‹ãƒãƒ ãƒ¢ãƒ¼ãƒ‰ï¼šã‚·ãƒ³ãƒ—ãƒ«ã«ç·¨é›†ã§ãã¾ã™ã€‚"
      : "ãƒ—ãƒ­ãƒ¢ãƒ¼ãƒ‰ï¼šéšå±¤ãƒ»ã‚­ãƒ£ãƒ³ãƒã‚¹ãƒ»é·ç§»ãƒ•ãƒ­ãƒ¼ã‚’è‡ªç”±ã«ç·¨é›†ã§ãã¾ã™ã€‚";
    return;
  }
  if (!appState.structure) {
    guide.textContent = "ğŸ’¡ æ¬¡ã¯ã€Œã‚¢ãƒ—ãƒªã®èª¬æ˜ã€ã‚’æ›¸ã„ã¦ã¿ã‚ˆã†ã€‚ã‚ãªãŸã®è¨€è‘‰ã§å¤§ä¸ˆå¤«ã ã‚ˆã€‚";
  } else {
    guide.textContent = "ğŸ’¡ ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚„ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚’è§¦ã£ã¦ã¿ã‚ˆã†ã€‚å°‘ã—ãšã¤è‚²ã¦ã¦ã„ã‘ã°OKã€‚";
  }
}

/* å…¥åŠ› â†’ ãƒã‚¤ãƒ–ãƒªãƒƒãƒ‰ analyze èµ·å‹• */

const appInput = document.getElementById("appInput");
let inputTimer = null;

appInput.addEventListener("input", () => {
  if (inputTimer) clearTimeout(inputTimer);
  document.getElementById("autoSaveStatus").textContent = "è§£æä¸­â€¦";

  inputTimer = setTimeout(async () => {
    const text = appInput.value.trim();
    if (!text) {
      appState.structure = null;
      document.getElementById("autoSaveStatus").textContent = "å…¥åŠ›å¾…ã¡";
      rerenderAll();
      return;
    }
    appState.structure = await analyzeHybrid(text);
    document.getElementById("autoSaveStatus").textContent = "æ§‹é€ ç”Ÿæˆæ¸ˆã¿";
    rerenderAll();
  }, 600);
});

function rerenderAll() {
  renderPreview();
  renderTree(appState.structure);
  renderCanvas(appState.structure);
  renderPropertyPanel(null);
  renderScreenFlow();
  suggestNextActions();
  renderGuideMessage();
}

/* ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ï¼ˆãƒŸãƒ‹ãƒãƒ å´ï¼‰ */

function renderPreview() {
  const frame = document.getElementById("previewFrame");
  if (!appState.structure) {
    frame.innerHTML = `<div class="preview-placeholder">ã“ã“ã«ã‚ãªãŸã®ã‚¢ãƒ—ãƒªãŒè¡¨ç¤ºã•ã‚Œã¾ã™ã€‚</div>`;
    return;
  }
  const home = appState.structure.screens[0];
  let html = "";
  home.components.forEach(c => {
    if (c.type === "text") html += `<p>${c.text}</p>`;
    if (c.type === "textarea") html += `<p>${c.text}</p>`;
    if (c.type === "input") html += `<input placeholder="${c.text || ""}" style="width:100%;margin-bottom:8px;">`;
    if (c.type === "list") html += `<ul>${(c.items || ["ã‚¢ã‚¤ãƒ†ãƒ 1","ã‚¢ã‚¤ãƒ†ãƒ 2"]).map(i => `<li>${i}</li>`).join("")}</ul>`;
    if (c.type === "button") html += `<button>${c.text}</button>`;
  });
  frame.innerHTML = html;
}

/* æ¬¡ã«ã‚„ã‚‹ã“ã¨ */

function suggestNextActions() {
  const list = document.getElementById("nextActions");
  if (!appState.structure) {
    list.innerHTML = "<li>ã‚¢ãƒ—ãƒªã®èª¬æ˜ã‚’æ›¸ã„ã¦ã¿ã‚ˆã†</li>";
    return;
  }
  list.innerHTML = `
    <li>ãƒŸãƒ‹ãƒãƒ ãƒ¢ãƒ¼ãƒ‰ã‚’OFFã«ã—ã¦ãƒ—ãƒ­ãƒ¢ãƒ¼ãƒ‰ã‚’è©¦ã—ã¦ã¿ã‚‹</li>
    <li>ç”»é¢ã®èª¬æ˜ã‚’ã‚‚ã†å°‘ã—å…·ä½“çš„ã«æ›¸ãè¶³ã™</li>
    <li>ã€Œä¸€è¦§ã€ã€Œè©³ç´°ã€ã€Œè¨­å®šã€ãªã©ç”»é¢åã‚’ã¯ã£ãã‚Šæ›¸ã„ã¦ã¿ã‚‹</li>
  `;
}

/* éšå±¤ãƒ„ãƒªãƒ¼ */

function renderTree(struct) {
  const area = document.getElementById("treeContent");
  if (!area) return;
  if (!struct) {
    area.innerHTML = "<p>æ§‹é€ ãŒã‚ã‚Šã¾ã›ã‚“ã€‚</p>";
    return;
  }
  const html = struct.screens
    .map((s, si) => `
      <div class="tree-screen" data-screen="${si}" style="margin-bottom:6px;">
        <strong>${s.name}</strong> <span style="opacity:0.7;font-size:12px;">(${s.role || "roleæœªæ¨å®š"})</span>
        <ul style="list-style:none; padding-left:10px; margin:2px 0 0;">
          ${s.components.map((c, ci) => `<li class="tree-comp" data-screen="${si}" data-index="${ci}">ãƒ»${c.type}</li>`).join("")}
        </ul>
      </div>
    `)
    .join("");
  area.innerHTML = html;

  area.querySelectorAll(".tree-comp").forEach(el => {
    el.addEventListener("click", () => {
      const si = Number(el.dataset.screen);
      const ci = Number(el.dataset.index);
      appState.selectedComponent = { screen: si, index: ci };
      renderPropertyPanel(struct.screens[si].components[ci]);
    });
  });
}

/* ã‚­ãƒ£ãƒ³ãƒã‚¹ï¼ˆç°¡æ˜“ï¼‰ */

function renderCanvas(struct) {
  const area = document.getElementById("canvasArea");
  if (!area) return;
  if (!struct) {
    area.innerHTML = "<p>ç”»é¢ãŒã‚ã‚Šã¾ã›ã‚“ã€‚</p>";
    return;
  }
  const home = struct.screens[0];
  area.innerHTML = "";
  home.components.forEach((c, ci) => {
    const el = document.createElement(c.type === "button" ? "button" : "div");
    el.className = "canvas-item";
    el.textContent = c.text || c.type;
    el.style.marginBottom = "8px";
    el.style.padding = "6px 10px";
    el.style.borderRadius = "8px";
    el.style.background = "rgba(255,255,255,0.08)";
    el.addEventListener("click", () => {
      appState.selectedComponent = { screen: 0, index: ci };
      renderPropertyPanel(c);
    });
    area.appendChild(el);
  });
}

/* ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ãƒ‘ãƒãƒ«ï¼ˆãƒ†ã‚­ã‚¹ãƒˆç·¨é›†ã ã‘ï¼‰ */

function renderPropertyPanel(comp) {
  const panel = document.getElementById("propertyContent");
  if (!panel) return;
  if (!comp) {
    panel.innerHTML = "<p>ã‚­ãƒ£ãƒ³ãƒã‚¹ä¸Šã®è¦ç´ ã‚’é¸æŠã™ã‚‹ã¨è©³ç´°ãŒè¡¨ç¤ºã•ã‚Œã¾ã™ã€‚</p>";
    return;
  }
  panel.innerHTML = `
    <label>ãƒ†ã‚­ã‚¹ãƒˆ</label>
    <input id="prop-text" value="${comp.text || ""}">
  `;
  document.getElementById("prop-text").addEventListener("input", e => {
    comp.text = e.target.value;
    rerenderAll();
  });
}

/* SVG ç”»é¢é·ç§»ãƒ•ãƒ­ãƒ¼ */

function renderScreenFlow() {
  const struct = appState.structure;
  const svg = document.getElementById("flowSvg");
  const nodesLayer = document.getElementById("flowNodes");
  const canvas = document.getElementById("screenFlowCanvas");
  if (!svg || !nodesLayer || !canvas) return;

  nodesLayer.innerHTML = "";
  svg.innerHTML = "";

  if (!struct || !struct.screens || struct.screens.length === 0) return;

  const rect = canvas.getBoundingClientRect();
  const width = rect.width;
  const height = rect.height;
  svg.setAttribute("width", width);
  svg.setAttribute("height", height);

  const defs = document.createElementNS("http://www.w3.org/2000/svg", "defs");
  const marker = document.createElementNS("http://www.w3.org/2000/svg", "marker");
  marker.setAttribute("id", "arrow");
  marker.setAttribute("markerWidth", "10");
  marker.setAttribute("markerHeight", "10");
  marker.setAttribute("refX", "10");
  marker.setAttribute("refY", "3");
  marker.setAttribute("orient", "auto");
  marker.setAttribute("markerUnits", "strokeWidth");
  const pathMarker = document.createElementNS("http://www.w3.org/2000/svg", "path");
  pathMarker.setAttribute("d", "M0,0 L0,6 L9,3 z");
  pathMarker.setAttribute("fill", "#4d7cff");
  marker.appendChild(pathMarker);
  defs.appendChild(marker);
  svg.appendChild(defs);

  const centerX = width / 2;
  const centerY = height / 2;
  const radius = Math.min(width, height) / 2.5;
  const nodeCenters = {};

  struct.screens.forEach((s, i) => {
    const angle = (2 * Math.PI * i) / struct.screens.length;
    const x = centerX + radius * Math.cos(angle);
    const y = centerY + radius * Math.sin(angle);
    nodeCenters[s.id] = { x, y };

    const div = document.createElement("div");
    div.className = "flow-node";
    div.textContent = s.name || s.id;
    div.style.left = (x - 30) + "px";
    div.style.top = (y - 12) + "px";
    nodesLayer.appendChild(div);
  });

  (struct.transitions || []).forEach(tr => {
    const from = nodeCenters[tr.from];
    const to = nodeCenters[tr.to];
    if (!from || !to) return;

    const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
    const dx = to.x - from.x;
    const dy = to.y - from.y;
    const cx1 = from.x + dx * 0.3 - dy * 0.15;
    const cy1 = from.y + dy * 0.3 + dx * 0.15;
    const cx2 = from.x + dx * 0.7 - dy * 0.15;
    const cy2 = from.y + dy * 0.7 + dx * 0.15;
    const d = `M ${from.x} ${from.y} C ${cx1} ${cy1}, ${cx2} ${cy2}, ${to.x} ${to.y}`;
    path.setAttribute("d", d);
    path.setAttribute("fill", "none");
    path.setAttribute("stroke", "#4d7cff");
    path.setAttribute("stroke-width", "2");
    path.setAttribute("marker-end", "url(#arrow)");
    path.setAttribute("class", "transition-line");
    svg.appendChild(path);

    if (tr.label) {
      const midX = (from.x + to.x) / 2;
      const midY = (from.y + to.y) / 2;
      const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
      text.setAttribute("x", midX);
      text.setAttribute("y", midY - 6);
      text.setAttribute("fill", "#9aa4ff");
      text.setAttribute("font-size", "12");
      text.setAttribute("text-anchor", "middle");
      text.textContent = tr.label;
      svg.appendChild(text);
    }
  });
}

/* åˆæœŸåŒ– */

window.addEventListener("load", () => {
  setMinimalMode(true);
  renderGuideMessage();
});
</script>
</body>
</html>
